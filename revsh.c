static  char data [] =
#define      chk1_z     22
#define      chk1       ((&data[4]))
        "\041\117\370\270\055\344\074\215\175\136\245\056\312\346\372\037"
        "\100\071\162\224\057\065\227\010\302\074\330"
#define      msg1_z     65
#define      msg1       ((&data[43]))
        "\235\041\230\312\362\304\144\362\214\112\102\344\055\114\145\132"
        "\323\057\334\111\012\072\142\055\012\366\154\172\003\055\312\376"
        "\355\260\143\353\277\102\050\172\210\111\347\146\272\017\035\342"
        "\336\051\143\251\152\276\261\372\041\133\313\024\321\127\117\151"
        "\303\350\063\001\130\144\372\140\257\113\026\023\306\007\154\201"
        "\057\120\073\334\225"
#define      opts_z     1
#define      opts       ((&data[112]))
        "\104"
#define      tst2_z     19
#define      tst2       ((&data[117]))
        "\236\266\353\234\327\373\040\036\237\215\070\123\103\040\312\011"
        "\002\332\217\305\202\004\316\000\210\276\230"
#define      inlo_z     3
#define      inlo       ((&data[140]))
        "\310\065\272"
#define      rlax_z     1
#define      rlax       ((&data[143]))
        "\016"
#define      pswd_z     256
#define      pswd       ((&data[202]))
        "\057\061\063\211\202\157\145\027\064\363\361\032\320\305\270\207"
        "\260\125\207\071\023\040\214\304\175\104\147\147\106\115\065\166"
        "\177\150\000\001\330\146\030\014\131\012\046\052\317\337\262\177"
        "\064\071\270\110\132\105\015\327\212\165\243\115\305\030\351\170"
        "\166\257\067\311\333\055\006\316\262\142\255\301\130\072\323\175"
        "\175\101\067\152\115\120\077\141\056\342\257\363\373\230\153\161"
        "\110\242\072\043\320\101\362\203\243\240\104\374\332\030\172\130"
        "\132\261\302\250\002\001\011\060\344\270\044\337\121\217\121\231"
        "\062\213\275\002\314\260\205\160\120\312\154\053\342\347\203\074"
        "\231\106\344\233\110\356\314\054\246\360\014\370\200\135\221\262"
        "\351\117\265\265\377\073\046\120\005\223\173\350\172\377\044\023"
        "\106\011\257\216\367\173\273\236\154\307\226\355\045\050\240\016"
        "\167\125\304\167\221\352\307\226\176\102\176\370\102\243\014\210"
        "\254\273\027\244\067\322\103\244\232\332\221\300\003\062\316\172"
        "\210\223\361\031\175\271\257\374\374\056\364\076\321\001\307\176"
        "\275\336\043\364\261\147\231\113\102\053\013\105\135\332\300\345"
        "\155\262\376\353\153\256\347\147\335\334\246\256\336\155\055\233"
        "\113\121\220\375\270\051\111\372\124\125\100\262\057\000\230\235"
        "\263\227\211\036\105\161\206\042\116\054\321\054\231\377\307\345"
        "\120\127\343\011\201\054\004\326\201\104\077\320\302\165\107\101"
        "\335\107\103\266\255\133\302\007\145\350\062\064\307\344\264\374"
        "\036\155\105\170\262\122\120\074\310\220\015\212\005\124\314\343"
        "\234\017\231\112\152\133\121\320\103\204\005\013\151\271"
#define      date_z     1
#define      date       ((&data[510]))
        "\016"
#define      xecc_z     15
#define      xecc       ((&data[511]))
        "\327\277\304\301\213\002\246\275\316\102\060\041\044\044\207\241"
        "\121\026"
#define      lsto_z     1
#define      lsto       ((&data[529]))
        "\254"
#define      chk2_z     19
#define      chk2       ((&data[534]))
        "\300\311\025\317\233\026\043\134\362\106\245\011\100\223\333\120"
        "\273\275\001\261\042\211\005\142\137"
#define      shll_z     8
#define      shll       ((&data[557]))
        "\013\002\174\130\345\217\061\137\054\235\065\020"
#define      tst1_z     22
#define      tst1       ((&data[570]))
        "\026\047\361\253\062\076\114\344\164\270\213\207\320\133\356\315"
        "\223\137\342\300\370\166\025\253\171\144\050\313\005"
#define      msg2_z     19
#define      msg2       ((&data[600]))
        "\133\006\142\101\356\046\057\022\032\260\214\077\271\221\320\357"
        "\320\225\224\106\251\351\213\177\042"
#define      text_z     376
#define      text       ((&data[676]))
        "\156\363\054\054\244\067\056\332\110\074\171\022\122\241\004\267"
        "\311\317\274\103\261\053\236\267\215\340\067\260\353\313\242\132"
        "\276\317\206\143\007\264\075\117\361\267\141\103\131\145\373\043"
        "\065\267\146\346\343\005\236\341\034\126\163\263\315\142\245\246"
        "\016\264\323\225\363\220\061\112\052\335\062\007\267\266\300\130"
        "\064\346\226\240\201\107\055\131\053\314\104\015\045\253\355\031"
        "\054\017\147\140\322\153\340\330\334\177\061\020\365\205\015\161"
        "\026\235\114\373\162\121\003\106\205\044\001\264\130\055\377\135"
        "\373\202\273\337\316\152\303\032\237\346\144\067\115\226\000\005"
        "\111\367\320\331\275\154\137\371\115\063\252\334\214\156\136\361"
        "\024\307\361\051\167\123\270\031\257\342\174\105\023\267\241\305"
        "\234\070\201\267\207\240\067\116\333\036\246\024\201\360\375\372"
        "\222\312\155\365\005\217\220\012\261\170\144\153\064\046\077\036"
        "\041\166\215\040\215\125\301\273\054\043\021\323\345\240\015\063"
        "\122\015\332\165\330\212\150\007\257\115\151\001\223\312\300\232"
        "\220\274\031\103\056\237\043\072\140\332\160\263\312\221\022\305"
        "\124\225\245\124\011\365\375\154\040\170\335\204\105\030\320\017"
        "\267\110\341\225\130\027\066\370\023\177\361\032\015\150\125\006"
        "\173\030\315\230\026\367\047\321\143\360\206\337\363\013\165\132"
        "\240\214\004\117\267\116\365\340\120\212\057\011\177\013\367\354"
        "\006\034\205\043\164\124\277\026\025\030\027\370\112\125\246\110"
        "\153\014\001\261\055\376\257\045\023\351\161\022\100\014\052\076"
        "\202\003\332\146\027\137\031\000\015\042\344\264\244\161\153\046"
        "\043\254\372\376\302\044\170\173\020\157\362\322\310\374\255\023"
        "\270\361\142\067\052\377\002\337\356\017\260\215\110\214\330\113"
        "\372\243\073\151\215\340\235\117\044\037\077\172\023\241\362\344"
        "\335\143\314\154\352\014\352\210\370\031\324\223\026\046\361\161"
        "\345\325\041\321\241\304\053\137\223\262\303\232\146\001\351\130"
        "\270\113\233\021\261\226\064\346\116\233\315\062\241\154\243\206"
        "\102\304\130\343\210\204\103\034\066\006\266\235\007\240\365\300"
        "\354\221\322\235\050\007\204\167\243\122\251\104\277\114\313\001"
        "\020\044\345\231\250\050\266\336\057\154\174\067\015\161\370\371"
        "\003\313\227\053\322\033\242\166";
#define      hide_z     4096
#define SETUID  0
#define DEBUGEXEC       0
#define TRACEABLE       1
#define HARDENING       0
#define BUSYBOXON       0

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

static unsigned char stte[256], indx, jndx, kndx;

void stte_0(void)
{
        indx = jndx = kndx = 0;
        do {
                stte[indx] = indx;
        } while (++indx);
}


void key(void * str, int len)
{
        unsigned char tmp, * ptr = (unsigned char *)str;
        while (len > 0) {
                do {
                        tmp = stte[indx];
                        kndx += tmp;
                        kndx += ptr[(int)indx % len];
                        stte[indx] = stte[kndx];
                        stte[kndx] = tmp;
                } while (++indx);
                ptr += 256;
                len -= 256;
        }
}

void arc4(void * str, int len)
{
        unsigned char tmp, * ptr = (unsigned char *)str;
        while (len > 0) {
                indx++;
                tmp = stte[indx];
                jndx += tmp;
                stte[indx] = stte[jndx];
                stte[jndx] = tmp;
                tmp += stte[indx];
                *ptr ^= stte[tmp];
                ptr++;
                len--;
        }
}


#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
}

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/data/data/com.termux/files/usr/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++) fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
        char * cc, * cflags, * ldflags;
    char cmd[4096];

        cc = getenv("CC");
        if (!cc) cc = "clang";

        sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/data/data/com.termux/files/usr/tmp/shc_x.so", "/data/data/com.termux/files/usr/tmp/shc_x.c -ldl");
        if (system(cmd)) {remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return -1;}
        remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

        unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/data/data/com.termux/files/usr/tmp/shc_x.so",1);

    if(pid==0) {

        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);
        system(tmp2);
        memcpy(tmp2, str, lentmp);
        remove("/data/data/com.termux/files/usr/tmp/shc_x.so");
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}
    seccomp_hardening();

    exit(0);
}
#endif

int key_with_file(char * file)
{
        struct stat statf[1];
        struct stat control[1];

        if (stat(file, statf) < 0)
                return -1;
        memset(control, 0, sizeof(control));
        control->st_ino = statf->st_ino;
        control->st_dev = statf->st_dev;
        control->st_rdev = statf->st_rdev;
        control->st_uid = statf->st_uid;
        control->st_gid = statf->st_gid;
        control->st_size = statf->st_size;
        control->st_mtime = statf->st_mtime;
        control->st_ctime = statf->st_ctime;
        key(control, sizeof(control));
        return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
        int i;
        fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
        fprintf(stderr, "argc=%d\n", argc);
        if (!argv) {
                fprintf(stderr, "argv=<null>\n");
        } else {
                for (i = 0; i <= argc ; i++)
                        fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
        }
}
#endif

void rmarg(char ** argv, char * arg)
{
        for (; argv && *argv && *argv != arg; argv++);
        for (; argv && *argv; argv++)
                *argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
        char buff[512];
        unsigned long mask, m;
        int l, a, c;
        char * string;
        extern char ** environ;

        mask = (unsigned long)getpid();
        stte_0();
         key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
         key(&data, sizeof(data));
         key(&mask, sizeof(mask));
        arc4(&mask, sizeof(mask));
        sprintf(buff, "x%lx", mask);
        string = getenv(buff);
#if DEBUGEXEC
        fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
        l = strlen(buff);
        if (!string) {
                sprintf(&buff[l], "=%lu %d", mask, argc);
                putenv(strdup(buff));
                return 0;
        }
        c = sscanf(string, "%lu %d%c", &m, &a, buff);
        if (c == 2 && m == mask) {
                rmarg(environ, &string[-l - 1]);
                return 1 + (argc - a);
        }
        return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
        char procfile[BUFSIZ];
        sprintf(procfile, "/proc/%d/cmdline", pid);
        FILE* f = fopen(procfile, "r");
        if (f) {
                size_t size;
                size = fread(name, sizeof (char), sizeof (procfile), f);
                if (size > 0) {
                        if ('\n' == name[size - 1])
                                name[size - 1] = '\0';
                }
                fclose(f);
        }
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0)
        && (strcmp(name, "/bin/bash") != 0)
        && (strcmp(name, "sh") != 0)
        && (strcmp(name, "/bin/sh") != 0)
        && (strcmp(name, "sudo") != 0)
        && (strcmp(name, "/bin/sudo") != 0)
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0)
        && (strcmp(name, "/bin/gksudo") != 0)
        && (strcmp(name, "/usr/bin/gksudo") != 0)
        && (strcmp(name, "kdesu") != 0)
        && (strcmp(name, "/bin/kdesu") != 0)
        && (strcmp(name, "/usr/bin/kdesu") != 0)
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC)
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC     PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
        char proc[80];
        int pid, mine;

        switch(pid = fork()) {
        case  0:
                pid = getppid();
#if defined(__FreeBSD__)
                sprintf(proc, "/proc/%d/mem", (int)pid);
#else
                sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
                close(0);
                mine = !open(proc, O_RDWR|O_EXCL);
                if (!mine && errno != EBUSY)
                        mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
                if (mine) {
                        kill(pid, SIGCONT);
                } else {
                        perror(argv0);
                        kill(pid, SIGKILL);
                }
                _exit(mine);
        case -1:
                break;
        default:
                if (pid == waitpid(pid, 0, 0))
                        return;
        }
        perror(argv0);
        _exit(1);
}
#endif

char * xsh(int argc, char ** argv)
{
        char * scrpt;
        int ret, i, j;
        char ** varg;
        char * me = argv[0];
        if (me == NULL) { me = getenv("_"); }
        if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

        ret = chkenv(argc);
        stte_0();
         key(pswd, pswd_z);
        arc4(msg1, msg1_z);
        arc4(date, date_z);
        if (date[0] && (atoll(date)<time(NULL)))
                return msg1;
        arc4(shll, shll_z);
        arc4(inlo, inlo_z);
        arc4(xecc, xecc_z);
        arc4(lsto, lsto_z);
        arc4(tst1, tst1_z);
         key(tst1, tst1_z);
        arc4(chk1, chk1_z);
        if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
                return tst1;
        arc4(msg2, msg2_z);
        if (ret < 0)
                return msg2;
        varg = (char **)calloc(argc + 10, sizeof(char *));
        if (!varg)
                return 0;
        if (ret) {
                arc4(rlax, rlax_z);
                if (!rlax[0] && key_with_file(shll))
                        return shll;
                arc4(opts, opts_z);
#if HARDENING
            arc4_hardrun(text, text_z);
            exit(0);
       seccomp_hardening();
#endif
                arc4(text, text_z);
                arc4(tst2, tst2_z);
                 key(tst2, tst2_z);
                arc4(chk2, chk2_z);
                if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
                        return tst2;
                scrpt = malloc(hide_z + text_z);
                if (!scrpt)
                        return 0;
                memset(scrpt, (int) ' ', hide_z);
                memcpy(&scrpt[hide_z], text, text_z);
        } else {
                if (*xecc) {
                        scrpt = malloc(512);
                        if (!scrpt)
                                return 0;
                        sprintf(scrpt, xecc, me);
                } else {
                        scrpt = me;
                }
        }
        j = 0;
#if BUSYBOXON
        varg[j++] = "busybox";
        varg[j++] = "sh";
#else
        varg[j++] = argv[0];
#endif
        if (ret && *opts)
                varg[j++] = opts;
        if (*inlo)
                varg[j++] = inlo;
        varg[j++] = scrpt;
        if (*lsto)
                varg[j++] = lsto;
        i = (ret > 1) ? ret : 0;
        while (i < argc)
                varg[j++] = argv[i++];
        varg[j] = 0;
#if DEBUGEXEC
        debugexec(shll, j, varg);
#endif
        execvp(shll, varg);
        return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
        debugexec("main", argc, argv);
#endif
#if HARDENING
        hardening();
#endif
#if !TRACEABLE
        untraceable(argv[0]);
#endif
        argv[1] = xsh(argc, argv);
        fprintf(stderr, "%s%s%s: %s\n", argv[0],
                errno ? ": " : "",
                errno ? strerror(errno) : "",
                argv[1] ? argv[1] : "<null>"
        );
        return 1;
}
